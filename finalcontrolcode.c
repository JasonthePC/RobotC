#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    fbAccel,        sensorAccelerometer)
#pragma config(Sensor, in2,    lrAccel,        sensorAccelerometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftSpineSW,    sensorTouch)
#pragma config(Sensor, dgtl2,  rightSpineSW,   sensorTouch)
#pragma config(Sensor, dgtl3,  ballSW,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rareLaunch,    tmotorVex393_HBridge, PIDControl, encoderPort, I2C_5)
#pragma config(Motor,  port2,           rightForward,  tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftForward,   tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           rightRear,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           leftRear,      tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port6,           leftSpine,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightSpine,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           cam,           tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          pepesLaunch,   tmotorVex393_HBridge, PIDControl, reversed, encoderPort, I2C_6)
#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float xPos = 0.0; //in inches (forward/back)
float zPos = 0.0; //in inches  (left/right)
float angle = 0.0; //in degrees (follows standard counterclockwise orientation)

bool ballArr[] = {false,false,false,false}; //first element is for lowest ball
bool needIntake = true;
bool driverMovement = true;
string display = "No output";

////////////////////////////////////////Begin code for loading mechanism////////////////////////////////////////
void ballArrUp(bool isThereBall){
	bool tempArr[] = {ballArr[0],ballArr[1],ballArr[2],ballArr[3]};
	for(int i=0; i<2; i++){
		ballArr[i+1]=tempArr[i];
	}
	ballArr[0]=isThereBall;
}

task leftSpineRotate(){
	display="rotating motors";
	setMotor(leftSpine,100);
	while(true){
		if(SensorValue[leftSpineSW]==1){
			stopMotor(leftSpine);
			break;
		}
		EndTimeSlice();
	}
}

task rightSpineRotate(){
	setMotor(leftSpine,100);
	while(true){
		if(SensorValue[leftSpineSW]==1){
			stopMotor(leftSpine);
			break;
		}
		EndTimeSlice();
	}
}

void ballStorageUp(){
	//display="Going up";

	//startTask(leftSpineRotate);
	//display="Stopped spine";
}
////////////////////////////////////////End code for loading mechanism////////////////////////////////////////

/*
void computeAngleToGoal(float myAngle){

}

task positionTracking(){

}

task aimBot(){
//turn robot to the goal and shoot
}
*/

task driverInputHandler(){
	while(true){
		//set up manual controls here
		//set up call to aimbot here and shutdown of driver controlled movement
		if(driverMovement){
			setMotor( rightForward, vexRT(Ch2) );
			setMotor( rightRear , vexRT(Ch2) );
			setMotor( leftForward , vexRT(Ch3) );
			setMotor( leftRear , vexRT(Ch3) );
		}
		EndTimeSlice();
	}
}

task lcdDisplay(){
	bLCDBacklight = true;
	string mainBattery;
	while(true){
		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0,0,display);

		displayLCDString(1, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		wait1Msec(100);
	}
}

task ballHandler(){
	while(true){

		//check if top space of spine is full
		if(ballArr[3]){
			needIntake=false;
			//display="Stopping intake";
		}
		else needIntake=true;

		if(needIntake){ //start the rollers and wait for ball
			//display="Starting rollers";
			setMotor(intake,127);
			if(SensorValue[ballSW]==1){ //what to do if ball is encountered
				display="detected ball";
				startTask(rightSpineRotate);
				startTask(leftSpineRotate);
				while(SensorValue[ballSW]==1){}
				//ballArrUp(true); //update the ballArray while indicating there is a ball coming in
				display="Done";
			}
			else{
				EndTimeSlice();
			}
		}
		else{ //what to do if intake is not needed
			stopMotor(intake); //maybe replace this later with code that runs intake in reverse then stops to clear any balls
			EndTimeSlice();
		}

	}
}

task main(){
	//startTask(positionTracker)
	startTask(lcdDisplay);
	startTask(driverInputHandler);
	startTask(ballHandler);
	while(true){
		EndTimeSlice();
	}
}
