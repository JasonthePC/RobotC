#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in4,    fbAccel,        sensorAccelerometer)
#pragma config(Sensor, in5,    lrAccel,        sensorAccelerometer)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftSpineSW,    sensorTouch)
#pragma config(Sensor, dgtl2,  rightSpineSW,   sensorTouch)
#pragma config(Sensor, dgtl3,  ballSW,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rareLaunch,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port2,           rightForward,  tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftForward,   tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           rightRear,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           leftRear,      tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port6,           leftSpine,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightSpine,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           cam,           tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          pepesLaunch,   tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_6)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float xPos = 0.0; //in inches (forward/back)
float zPos = 0.0; //in inches  (left/right)
float angle = 0.0; //in degrees (follows standard counterclockwise orientation)

bool ballArr[] = {false,false,false,false}; //first element is for lowest ball
bool needIntake = true;
bool driverMovement = true;
string display = "No output";

////////////////////////////////////////Begin code for loading mechanism////////////////////////////////////////

void ballArrUp(bool isThereBall){
	bool tempArr[] = {ballArr[0],ballArr[1],ballArr[2],ballArr[3]};
	for(int i=0; i<3; i++){
		ballArr[i+1]=tempArr[i];
	}
	ballArr[0]=isThereBall;
}

void ballStorageUp(){
	setMotor(leftSpine,127);
	setMotor(rightSpine,127);
	bool leftWasPressed=false;
	bool rightWasPressed=false;
	while(motor[leftSpine]!=0||motor[rightSpine]!=0){
		if(SensorValue[leftSpineSW]==1) leftWasPressed=true;
		if(SensorValue[rightSpineSW]==1) rightWasPressed=true;
		if(SensorValue[leftSpineSW]==0&&leftWasPressed) setMotor(leftSpine,0);
		if(SensorValue[rightSpineSW]==0&&rightWasPressed) setMotor(rightSpine,0);
		wait1Msec(10);
	}
}
////////////////////////////////////////End code for loading mechanism////////////////////////////////////////

/*
void computeAngleToGoal(float myAngle){

}

task positionTracking(){

}

task aimBot(){
//turn robot to the goal and shoot
}
*/

task driverInputHandler(){
	while(true){
		//set up manual controls here
		if(vexRT(Btn6U)==1){
			ballStorageUp();
			ballArrUp(false);
		}
		//set up call to aimbot here and shutdown of driver controlled movement
		if(driverMovement){
			setMotor( rightForward, vexRT(Ch2) );
			setMotor( rightRear , vexRT(Ch2) );
			setMotor( leftForward , vexRT(Ch3) );
			setMotor( leftRear , vexRT(Ch3) );
		}
		EndTimeSlice();
	}
}

task lcdDisplay(){
	bLCDBacklight = true;
	string mainBattery;
	while(true){
		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0,0,display);

		displayLCDString(1, 0, "Battery: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		wait1Msec(100);
	}
}

task ballHandler(){
	while(true){
		//if(nLCDButtons==1) ballArr[3]=false;
		//check if top space of spine is full
		if(ballArr[3]){
			needIntake=false;
			//display="Stopping intake";
		}
		else needIntake=true;

		if(needIntake){ //start the rollers and wait for ball
			setMotor(intake,127);
			if(SensorValue[ballSW]==1){ //what to do if ball is encountered
				ballStorageUp();
				ballArrUp(true); //update the ballArray while indicating there is a ball coming in
				while(SensorValue[ballSW]==1){EndTimeSlice();}
			}
			else{
				EndTimeSlice();
			}
		}
		else{ //what to do if intake is not needed
			stopMotor(intake); //maybe replace this later with code that runs intake in reverse then stops to clear any balls
			EndTimeSlice();
		}

	}
}

task main(){
	//startTask(positionTracker)
	startTask(lcdDisplay);
	startTask(driverInputHandler);
	//startTask(ballHandler);
  setMotor(pepesLaunch,127);
  setMotor(rareLaunch,127);
  wait1Msec(2500);
  setMotor(cam,127);
  wait1Msec(1000);
  stopAllMotors();
	while(true){
		EndTimeSlice();
	}
}
